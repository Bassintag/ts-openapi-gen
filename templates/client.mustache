/* Generated by ts-openapi-gen, do not edit manually */

import { {{#endpoints}}{{capitalizedName}}Endpoint, {{/endpoints}} } from './index';

export interface EndpointFetchResponse {
  blob: () => Promise<Blob>;
  text: () => Promise<string>;
}

export interface EndpointFetchOptions {
  method?: string;
  body?: string | Blob;
  headers?: Record<string, string>;
  auth?: string
}

export type EndpointFetchApi = (
    url: string,
    options?: EndpointFetchOptions
) => Promise<EndpointFetchResponse>;

export interface FetchResponse extends EndpointFetchResponse {
  ok: boolean;
}

export interface FetchOptions extends EndpointFetchOptions {
}

export type FetchApi = (
  url: string,
  options?: FetchOptions
) => Promise<FetchResponse>;

export interface ClientOptions {
    baseUrl?: string;
    fetch?: FetchApi;
}

export class Client {

    {{#endpoints}}
    readonly {{uncapitalizedName}}: {{capitalizedName}}Endpoint;

    {{/endpoints}}
    constructor({ baseUrl, fetch = window.fetch }: ClientOptions = {}) {
        const wrappedFetch = this.wrapFetch(fetch);
        {{#endpoints}}
        this.{{uncapitalizedName}} = new {{capitalizedName}}Endpoint(baseUrl, wrappedFetch);
        {{/endpoints}}
    }

    private wrapFetch(fetch: FetchApi): EndpointFetchApi {
        return async (url, options) => {
            const response = await fetch(url, options);
            if (!response.ok) {
              throw response;
            }
            return response;
        };
    }
}
