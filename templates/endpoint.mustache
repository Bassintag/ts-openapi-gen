/* Generated by ts-openapi-gen, do not edit manually */

import { {{#dependsOn}}{{name}}, serialize{{name}}, {{/dependsOn}}EndpointFetchApi } from '..';

{{#methods}}
    {{#queryParams.length}}
export interface {{capitalizedName}}Query {
        {{#queryParams}}

    {{name}}?: string;
        {{/queryParams}}
}

    {{/queryParams.length}}
    {{#hasDifferentReturns}}
interface {{capitalizedName}}Returns {
        {{#returns}}
    ["{{&contentType}}"]: {{type}};
        {{/returns}}
}

    {{/hasDifferentReturns}}
    {{#hasDifferentBodies}}
interface {{capitalizedName}}Bodies {
        {{#bodies}}
    ["{{&contentType}}"]: {{type}};
        {{/bodies}}
}

    {{/hasDifferentBodies}}
{{/methods}}
export class {{capitalizedName}}Endpoint {

    private readonly fetch: EndpointFetchApi;

    constructor(
        private readonly baseUrl?: string,
        fetch: EndpointFetchApi = window.fetch,
    ) {
        this.fetch = fetch;
    }

{{#methods}}
    async {{name}}{{#hasDifferentReturnsOrBodies}}<{{#hasDifferentReturns}}AcceptT extends {{&returnContentTypes}}, {{/hasDifferentReturns}}{{#hasDifferentBodies}}ContentTypeT extends {{&bodiesContentType}}{{/hasDifferentBodies}}>{{/hasDifferentReturnsOrBodies}}(
        {{#params}}
        {{name}}: string,
        {{/params}}
        {{#hasDifferentReturns}}
        accept: AcceptT,
        {{/hasDifferentReturns}}
        {{#hasBody}}
        {{#hasDifferentBodies}}
        contentType: ContentTypeT,
        body: {{capitalizedName}}Bodies[ContentTypeT],
        {{/hasDifferentBodies}}
        {{^hasDifferentBodies}}
        body: {{bodyType}},
        {{/hasDifferentBodies}}
        {{/hasBody}}
        {{#queryParams.length}}
        queryParams: {{capitalizedName}}Query = {},
        {{/queryParams.length}}
    ): Promise<{{#hasDifferentReturns}}{{capitalizedName}}Returns[AcceptT]{{/hasDifferentReturns}}{{#hasOneReturn}}{{returnType}}{{/hasOneReturn}}{{^hasOneReturn}}{{^hasDifferentReturns}}void{{/hasDifferentReturns}}{{/hasOneReturn}}> {
        const url = new URL(`{{&templatedPath}}`, this.baseUrl);
    {{#queryParams.length}}
        url.search = new URLSearchParams(queryParams as Record<string, string>).toString();
    {{/queryParams.length}}

        const response = await this.fetch(url.toString(), {
            method: '{{method}}',
            headers: {
            {{#hasDifferentReturns}}
                "Accept": accept,
            {{/hasDifferentReturns}}
            {{#hasOneReturn}}
                "Accept": '{{&return.contentType}}',
            {{/hasOneReturn}}
            {{#hasDifferentBodies}}
                "Content-Type": contentType,
            {{/hasDifferentBodies}}
            {{#hasOneBody}}
                "Content-Type": '{{&body.contentType}}',
            {{/hasOneBody}}
            },
            {{#hasOneBody}}
            body: {{#body.serialize}}{{#body.model.name}}serialize{{body.model.name}}({{/body.model.name}}body{{#body.model.name}}){{/body.model.name}}{{/body.serialize}},
            {{/hasOneBody}}
            {{#auth}}
            auth: "{{auth}}"
            {{/auth}}
        });
        {{#hasOneReturn}}

        const responseBody = await response.{{return.bodyGetter}}();
        return {{#return.deserialize}}responseBody{{/return.deserialize}} as {{&return.type}};
        {{/hasOneReturn}}
        {{#hasDifferentReturns}}

        switch (accept) {
            {{#returns}}
            case '{{&contentType}}':
                const responseBody{{name}} = await response.{{bodyGetter}}()
                return {{#deserialize}}responseBody{{name}}{{/deserialize}} as {{capitalizedName}}Returns[AcceptT];
            {{/returns}}
            default:
                throw new Error('Invalid accept header');
        }
        {{/hasDifferentReturns}}
    }

{{/methods}}
}
